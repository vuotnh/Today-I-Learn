```table-of-contents
```

# ***Dining Philosophers Problem***
***Dining Philosophers Problem*** lÃ  má»™t vÃ­ dá»¥ kinh Ä‘iá»ƒn trong concurrency vÃ  há»‡ Ä‘iá»u hÃ nh, nÃ³ dÃ¹ng Ä‘á»ƒ minh há»a cÃ¡c váº¥n Ä‘á» nhÆ° ***deadlock, starvation (thiáº¿u tÃ i nguyÃªn) vÃ  synchronization (Ä‘á»“ng bá»™ hÃ³a) giá»¯a cÃ¡c tiáº¿n trÃ¬nh***.

Khi cÃ³ *nhiá»u tiáº¿n trÃ¬nh cÃ¹ng cáº¡nh tranh tÃ i nguyÃªn*, má»—i tiáº¿n trÃ¬nh *cáº§n nhiá»u tÃ i nguyÃªn* Ä‘á»ƒ lÃ m viá»‡c, náº¿u *khÃ´ng cÃ³ cÃ¡ch Ä‘á»“ng bá»™ há»£p lÃ½*, há»‡ thá»‘ng cÃ³ thá»ƒ rÆ¡i vÃ o tráº¡ng thÃ¡i:
* Deadlock
* Startvation (thiáº¿u tÃ i nguyÃªn)
* Race condition (xung Ä‘á»™t tÃ i nguyÃªn)

Code sá»­ dá»¥ng Python vÃ  RLocks Ä‘á»ƒ mÃ´ táº£ váº¥n Ä‘á» deadlock

```python
class Philosopher(threading.Thread):
	def __init__(self, leftFork, rightFork):
	print("Our Philosopher Has Sat Down At the Table")
	threading.Thread.__init__(self)
	self.leftFork = leftFork
	self.rightFork = rightFork

	def run(self):
		print("Philosopher: {} has started thinking".formatthreading.current_thread()))
		while True:
			time.sleep(random.randint(1,5))
			print("Philosopher {} has finished thinking".format(threading.current_thread()))
			self.leftFork.acquire()
			time.sleep(random.randint(1,5))
			try:
				print("Philosopher {} has acquired the left fork".format(threading.current_thread()))
				self.rightFork.acquire()
				try:
					print("Philosopher {} has attained both forks, currently eating".format(threading.current_thread()))
				finally:
					self.rightFork.release()
					print("Philosopher {} has released the right fork".format(threading.current_thread()))
			finally:
				self.leftFork.release()
				print("Philosopher {} has released the left fork".format(threading.current_thread()))
```


# ***Race condition***

VÃ­ dá»¥ trÃªn lÃ  vÃ­ dá»¥ Ä‘iá»ƒn hÃ¬nh vá» deadlock, váº¥n Ä‘á» tiáº¿p theo cáº§n bÃ n tá»›i lÃ  race condition.
***Race condition*** xáº£y ra khi 2 hoáº·c nhiá»u process/thread ***cÃ¹ng truy cáº­p vÃ  thay Ä‘á»•i dá»¯ liá»‡u dÃ¹ng chung mÃ  khÃ´ng Ä‘Æ°á»£c Ä‘á»“ng bá»™ Ä‘Ãºng cÃ¡ch*** â¡ï¸ Sai lá»‡ch vá» dá»¯ liá»‡u.

VÃ­ dá»¥ Ä‘iá»ƒn hÃ¬nh:
- Sá»‘ dÆ° tÃ i khoáº£n ban Ä‘áº§u: **Â£2,000**
- CÃ³ **2 giao dá»‹ch diá»…n ra gáº§n nhÆ° Ä‘á»“ng thá»i**:
    - **Process A**: rÃºt tiá»n tráº£ tiá»n nhÃ  Â£1,000
    - **Process B**: nháº­n tiá»n thÆ°á»Ÿng Â£5,000
Náº¿u khÃ´ng cÃ³ gÃ¬ xáº£y ra, má»i thá»© hoáº¡t Ä‘á»™ng Ä‘Ãºng, thÃ¬ sau khi 2 giao dá»‹ch káº¿t thÃºc trong tÃ i khoáº£n sáº½ cÃ³ **Â£6,000**.
![[Pasted image 20250425000519.png]]

Tuy nhiÃªn khi Race condition sáº£y ra:
- **Process B** báº¯t Ä‘áº§u:
    - Äá»c sá»‘ dÆ°: Â£2,000
    - TÃ­nh: 2,000 + 5,000 = 7,000 (chÆ°a ghi láº¡i)
- **Ngay lÃºc Ä‘Ã³**, **Process A** cÅ©ng báº¯t Ä‘áº§u:
    - Äá»c **cÃ¹ng má»™t sá»‘ dÆ°**: Â£2,000
    - Trá»« 1,000 â†’ 1,000
    - **Ghi láº¡i káº¿t quáº£: Â£1,000**
- Sau Ä‘Ã³, **Process B hoÃ n thÃ nh vÃ  ghi sá»‘ dÆ°: Â£7,000**
![[Pasted image 20250425000534.png]]

## CÃ¡c giáº£i quyáº¿t (solution)
Sá»­ dá»¥ng transacions trong má»™t lock, khi thread 1 Ä‘á»c dá»¯ liá»‡u xong, chÆ°Æ¡ng trÃ¬nh sáº½ lock pháº§n data Ä‘Ã³ láº¡i, cÃ¡c thread khÃ¡c pháº£i chá» tá»›i khi data Ä‘Æ°Æ¡c release. Sau khi thread 1 Ä‘á»c dá»¯ liá»‡u, ghi dá»¯ liá»‡u xong, nÃ³ sáº½ release lock Ä‘á»ƒ cÃ¡c thread khÃ¡c Ä‘Æ°á»£c phÃ©p Ä‘á»c vÃ  ghi dá»¯ liá»‡u.

## Critical Section (vÃ¹ng giá»›i háº¡n)

***Critical Section***: lÃ  pháº§n code sá»­ dá»¥ng Ä‘á»ƒ truy cáº­p cÃ¡c shared resource (vÃ­ dá»¥ nhÆ° Ä‘oáº¡n code Ä‘á»ƒ Ä‘á»c, ghi dá»¯ liá»‡u xuá»‘ng database) cáº§n Ä‘Æ°á»£c bá»c trong má»™t lock hoáº·c transaction Ä‘á»ƒ Ä‘áº£m báº£o ***chá»‰ má»™t tiáº¿n trÃ¬nh hoáº·c threads*** Ä‘Æ°á»£c thá»±c thi code á»Ÿ ***critical section*** táº¡i ***má»™t thá»i Ä‘iá»ƒm***.


# Shared resources and data races (cÃ¡c phÆ°Æ¡ng phÃ¡p Ä‘á»“ng bá»™ dá»¯ liá»‡u)

Má»™t sá»‘ phÆ°Æ¡ng phÃ¡p thÆ°á»ng Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ Ä‘á»“ng bá»™ cÃ¡c shared resources vÃ  ngÄƒn cháº·n data races.

## Join method

Method `join()` cá»§a class `thread object` trong python giÃºp `block parent thread`.

Khi má»™t thread object gá»i tá»›i method `join`, nÃ³ sáº½ dá»«ng hoáº¡t Ä‘á»™ng cá»§a thread cha vÃ  chá» tá»›i khi nÃ o `thread con` Ä‘Ã£ hoÃ n thÃ nh cÃ´ng viÃªc cá»§a nÃ³, khÃ´ng cÃ³ exception nÃ o Ä‘Æ°á»£c báº¯n ra thÃ¬ sáº½ tiáº¿p tá»¥c thá»±c thi tiáº¿p logic cá»§a thread cha.
Tuy nhiÃªn náº¿u thread con bá»‹ `raise Exception` mÃ  khÃ´ng xá»­ lÃ½,  thÃ¬ thread cha váº«n cháº¡y tiáº¿p chÆ°Æ¡ng trÃ¬nh. ***VÃ¬ má»¥c tiÃªu cá»§a join() lÃ  chá»‰ Ä‘á»£i tá»›i khi thread káº¿t thÃºc, khÃ´ng quan tÃ¢m lÃ  cháº¡y thÃ nh cÃ´ng hay lá»—i***.

```python
import threading
import time

def ourThread(i):
	print("Thread {} Started".format(i))
	time.sleep(i*2)
	print("Thread {} Finished".format(i))

def main():
	thread1 = threading.Thread(target=ourThread, args=(1,))
	thread1.start()
	print("Is thread 1 Finished?")
	thread2 = threading.Thread(target=ourThread, args=(2,))
	thread2.start()
	thread2.join()
	print("Thread 2 definitely finished")

if __name__ == '__main__':
	main()
```

âš ï¸Trong vÃ­ dá»¥ trÃªn,  cáº£ 2 thread sinh ra Ä‘á»u lÃ  cÃ¡c ***non-daemon*** thread, do Ä‘Ã³ dÃ¹ cÃ³ gá»i hÃ m `join()` hay khÃ´ng thÃ¬ <span style="color: red">main thread váº«n sáº½ chá» tá»›i khi cÃ¡c thread con cháº¡y xong thÃ¬ má»›i exit</span>. Chá»‰ khÃ¡c nhau lÃ 
* Khi dÃ¹ng `join()` chÆ°Æ¡ng trÃ¬nh sáº½ dá»«ng láº¡i Ä‘á»ƒ chá», *khÃ´ng print dÃ²ng cuá»‘i ngay*
* Náº¿u khÃ´ng dÃ¹ng `join()` thÃ¬ chÆ°Æ¡ng trÃ¬nh sáº½ ***cháº¡y háº¿t cÃ¡c lá»‡nh trong main thread***, sau Ä‘Ã³ chÆ°a thoÃ¡t ngay mÃ  chá» thread con cháº¡y xong má»›i exit.
ğŸ›‘Náº¿u muá»‘n main thread thoÃ¡t ngay mÃ  khÃ´ng chá» cÃ¡c thread con thÃ¬ ta cáº§n cáº¥u hÃ¬nh cho cÃ¡c thread con thÃ nh cÃ¡c ***daemon thread***
```python
import threading
import time

def ourThread(i):
	print("Thread {} Started".format(i))
	time.sleep(i*2)
	print("Thread {} Finished".format(i))

def main():
	start = time.time()
	thread1 = threading.Thread(target=ourThread, args=(1,))
	thread1.start()
	print("Is thread 1 Finished?")
	thread2 = threading.Thread(target=ourThread, args=(5,))
	thread2.daemon = True
	thread2.start()
	# thread2.join() # Náº¿u dÃ¹ng join thÃ¬ main thread váº«n chá» bÃ¬nh thÆ°á»ng
	print("Thread 2 definitely finished")
	end_time = time.time()
	print(f"Time: {end_time - start}")
	return

if __name__ == '__main__':
	main()
```

## ***Locks***

***Locks*** lÃ  má»™t cÆ¡ cháº¿ Ä‘á»“ng bá»™ hÃ³a Ä‘Æ°á»£c sá»­ dá»¥ng khi nhiá»u thread Ä‘á»u truy cáº­p vÃ o cÃ¹ng *shared resources*.
Khi má»™t thread hoáº·c process Ä‘ang sá»­ dá»¥ng tÃ i nguyÃªn thÃ¬ cÃ¡c actor khÃ¡c khÃ´ng Ä‘Æ°á»£c truy cáº­p tÃ i nguyÃªn Ä‘Ã³.

VÃ­ dá»¥: Khi khÃ´ng sá»­ dá»¥ng lock, 2 thread cÃ¹ng thay Ä‘á»•i má»™t biáº¿n global â‡’ sai lá»‡nh vá» giÃ¡ trá»‹

```python
import threading
import time
import random

counter = 1
def workerA():
    global counter
    while counter < 1000:
        counter += 1
        print("Worker A is incrementing counter to {}".format(counter))
        sleepTime = random.randint(0,1)
        time.sleep(sleepTime)

def workerB():
    global counter
    while counter > -1000:
        counter -= 1
        print("Worker B is decrementing counter to {}".format(counter))
        sleepTime = random.randint(0,1)
        time.sleep(sleepTime)

def main():
    t0 = time.time()
    thread1 = threading.Thread(target=workerA)
    thread2 = threading.Thread(target=workerB)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    t1 = time.time()
    print("Execution Time {}".format(t1-t0))
if __name__ == '__main__':
    main()
```

Sá»­ dá»¥ng lock Ä‘á»ƒ chá»‰ cho phÃ©p 1 thread Ä‘Æ°á»£c truy cáº­p vÃ o giÃ¡ trá»‹ cá»§a biáº¿n
```python
import threading
import time
import random

counter = 1
lock = threading.Lock()

def workerA():
    global counter
    lock.acquire() # trÆ°á»›c khi truy cáº­p value cá»§a biáº¿n thÃ¬ acquire lock
    try:
        while counter < 1000:
            counter += 1
            print("Worker A is incrementing counter to {}".format(counter))
            sleepTime = random.randint(0,1)
            time.sleep(sleepTime)
    finally:
        lock.release() # Sau khi sá»­ dá»¥ng xong thÃ¬ release lock

def workerB():
    global counter
    lock.acquire()
    try:
        while counter > -1000:
            counter -= 1
            print("Worker B is decrementing counter to {}".format(counter))
            sleepTime = random.randint(0,1)
            time.sleep(sleepTime)
    finally:
        lock.release()

def main():
    t0 = time.time()
    thread1 = threading.Thread(target=workerA)
    thread2 = threading.Thread(target=workerB)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    t1 = time.time()
    print("Execution Time {}".format(t1-t0))
if __name__ == '__main__':
    main()
```

## **RLocks**

***Reentrant-locks*** hay ***RLocks*** lÃ  cÆ¡ cháº¿ Ä‘á»“ng bá»™ hoáº¡t Ä‘á»™ng giá»‘ng nhÆ° ***locks*** thÃ´ng thÆ°á»ng, tuy nhiÃªn ***RLocks*** cÃ³ thá»ƒ Ä‘Æ°á»£c <span style="color: red">má»™t thread acquired nhiá»u láº§n náº¿u thread Ä‘Ã³ Ä‘ang hold lock Ä‘Ã³</span>.

Vá»›i lock thÃ´ng thÆ°á»ng:
- Khi thread *Ä‘ang hold lock* mÃ  nÃ³ tiáº¿p tá»¥c `acquired lock` má»™t láº§n ná»¯a â¡ï¸ xáº£y ra `deadlock`.
Vá»›i RLocks:
* Khi `thread-1` gá»i `.acquire()` láº§n Ä‘áº§u tiÃªn, nÃ³ sáº½ giá»¯ RLock, vÃ  má»™t counter sáº½ tÄƒng lÃªn  = 1
* Khi `thread-1` gá»i `.acquire()` láº§n ná»¯a, counter sáº½ tÄƒng lÃªn 2, vÃ  thread Ä‘Ã³ váº«n giá»¯ lock (khÃ´ng bá»‹ block)
* Má»—i láº§n `thead-1` gá»i `.release()`, counter sáº½ giáº£m Ä‘i 1
* Khi `counter = 0` thÃ¬ lock má»›i Ä‘Æ°á»£c `release` hoÃ n toÃ n, khi Ä‘Ã³ cÃ¡c thread khÃ¡c má»›i cÃ³ thá»ƒ `acquired`.
```python
import threading
import time

class myWorker():
    def __init__(self):
        self.a = 1
        self.b = 2
        self.Rlock = threading.RLock()

    def modifyA(self):
        with self.Rlock: # first acquire lock
            print("Modifying A : RLock Acquired: {}".format(self.Rlock._is_owned()))
            print("{}".format(self.Rlock))
            self.a = self.a + 1
            time.sleep(5)

    def modifyB(self):
        with self.Rlock: # first acquire lock
            print("Modifying B : RLock Acquired: {}".format(self.Rlock._is_owned()))
            print("{}".format(self.Rlock))
            self.b = self.b - 1
            time.sleep(5)

    def modifyBoth(self):
        with self.Rlock:
            print("Rlock acquired, modifying A and B")
            print("{}".format(self.Rlock))
            self.modifyA()
            self.modifyB()
            print("{}".format(self.Rlock))

workerA = myWorker()
workerA.modifyBoth()
```

Vá»›i vÃ­ dá»¥ trÃªn ta tháº¥y:
1. Äáº§u tiÃªn, `main thread` lÃ  hÃ m `modifyBoth` sáº½ dÃ¹ng `self.Rlock` Ä‘á»ƒ acquire RLocks láº§n Ä‘áº§u tiÃªn
2. Sau Ä‘Ã³ `modifyA` sáº½ láº¡i `acquire RLock` láº§n 2, lÃºc nÃ y counter = 2. Sau khi `modifiyA` hoÃ n thÃ nh, nÃ³ sáº½ `release lock`, khi Ä‘Ã³ counter giáº£m = 1
3. Tiáº¿p tÃºc `modifyB` sáº½ `acquire RLock`, lÃºc nÃ y counter láº¡i tÄƒng lÃªn 2. Sau `modifyB` release RLock, counter láº¡i trá»Ÿ vá» 1.
4. `modifyBoth` káº¿t thÃºc vÃ  release RLock hoÃ n toÃ n.

Náº¿u á»Ÿ Ä‘Ã¢y sá»­ dá»¥ng lock thÃ´ng thÆ°á»ng, thÃ¬ `modifyBoth` Ä‘Ã£ hold lock ngay tá»« Ä‘áº§u, do Ä‘Ã³ `modifyA` sáº½ khÃ´ng bao giá» Ä‘Æ°á»£c cháº¡y.

***Use case***: Ä‘Æ°á»£c sá»­ dá»¥ng khi hÃ m gá»i hÃ m, method gá»i method vÃ  <span style="color: red">cÃ¡c hÃ m nÃ y dÃ¹ng chung má»™t lock</span>.

## ***Condition***

***Condition*** lÃ  má»™t cÆ¡ cháº¿ Ä‘á»“ng bá»™ mÃ  nÃ³ cáº§n pháº£i ***chá» má»™t signal tá»« má»™t thread khÃ¡c***.
VÃ­ dá»¥ khi má»™t thread Ä‘Ã³ hoÃ n thÃ nh nhiá»‡m vá»¥, thread khÃ¡c sáº½ tiáº¿p tá»¥c xá»­ lÃ½ logic *dá»±a trÃªn káº¿t quáº£ cá»§a thread cÅ©*.

MÃ´ hÃ¬nh nÃ y ba gá»“m má»™t `producer` sáº½ publish message vÃ o má»™t queue vÃ  notify má»™t thread khÃ¡c Ä‘Ã³ng vai trÃ² lÃ  `consumers` Ä‘ang láº¯ng nghe message trÃªn queue.

```python
import threading
import random
import time

class Publisher(threading.Thread):
    def __init__(self, integers, condition, name="Publisher"):
        self.condition = condition
        self.integers = integers
        threading.Thread.__init__(self, name=name)
    def run(self):
        while True:
            integer = random.randint(0,1000)
            self.condition.acquire()
            print("Condition Acquired by Publisher: {}".format(self.name))
            self.integers.append(integer)
            self.condition.notify()
            print("Condition Released by Publisher: {}".format(self.name))
            self.condition.release()
            time.sleep(1)

class Subscriber(threading.Thread):
    def __init__(self, integers, condition, name):
        self.integers = integers
        self.condition = condition
        threading.Thread.__init__(self, name=name)

    def run(self):
        while True:
            self.condition.acquire()
            print("Condition Acquired by Consumer: {}".format(self.name))
            while True:
                if self.integers:
                    integer = self.integers.pop()
                    print("{} Popped from list by Consumer: {}".format(integer,
                    self.name))
                    break
                print("Condition Wait by {}".format(self.name))
                self.condition.wait()
            print("Consumer {} Releasing Condition".format(self.name))
            self.condition.release()

def main():
    integers = []
    condition = threading.Condition()
    # Our Publisher
    pub1 = Publisher(integers, condition)
    pub1.start()
    # Our Subscribers
    sub1 = Subscriber(integers, condition, name="Consumer-1")
    sub2 = Subscriber(integers, condition, name="Consumer-2")
    sub1.start()
    sub2.start()
    ## Joining our Threads
    pub1.join()
    sub1.join()
    sub2.join()

if __name__ == '__main__':
    main()

```

Trong vÃ­ dá»¥ trÃªn:
1. `publisher` sáº½ random má»™t sá»‘ nguyÃªn. Sau Ä‘Ã³ sáº½ `acquire condition`, append sá»‘ nguyÃªn vá»«a rá»“i vÃ o máº£ng cÃ¡c sá»‘ nguyÃªn.
2. Sau khi thÃªm sá»‘ vÃ o máº£ng, `publisher` sáº½ `notify` cho cÃ¡c `consumer` lÃ  cÃ³ item má»›i Ä‘Æ°á»£c thÃªm vÃ o máº£ng, sau Ä‘Ã³ `release condition` Ä‘á»ƒ cÃ¡c `consumer` cÃ³ thá»ƒ acquire
3. 2 `consumer` sáº½ cá»‘ gáº¯ng `acquire condition`, `consumer` nÃ o `acquire condition` trÆ°á»›c thÃ¬ sáº½ Ä‘á»c 1 sá»‘ nguyÃªn trong máº£ng, xá»­ lÃ½ logic, sau Ä‘Ã³ chá» láº§n `notify` tiáº¿p theo cá»§a `publisher`.

âš ï¸ ***ChÃº Ã½***:
Trong vÃ²ng láº·p while cá»§a `consumer`, chÃºng ta chá»‰ gá»i `condition.wait()` lÃ  chÆ°a `condition.release()` vÃ¬
- `condition.wait()` sáº½ `táº¡m thá»i` nháº£ `condition lock` Ä‘á»ƒ cho `publisher` cÃ³ thá»ƒ tiáº¿p tá»¥c `acquire lock`.
- `consumer` lÃºc nÃ y sáº½ vÃ o tráº¡ng thÃ¡i chá», chá» tá»›i khi `publisher` gá»i `condition.notify()` láº§n tiáº¿p theo thÃ¬ sáº½ thá»©c dáº­y tiáº¿p tá»¥c xá»­ lÃ½.
- Náº¿u khÃ´ng gá»i `condition.wait()` thÃ¬ `consumer` sáº½ hold lock mÃ£i mÃ£i vÃ  `publisher` sáº½ khÃ´ng thá»ƒ thÃªm dá»¯ liá»‡u vÃ o array.

â“***Tháº¿ cÃ²n condition.release() á»Ÿ cuá»‘i ???***
Sau khi Ä‘Ã£ Ä‘á»c dá»¯ liá»‡u trong máº£ng vÃ  thá»±c hiá»‡n xong logic, `consumer-1` sáº½ `release condition` vÃ  tiáº¿p tá»¥c vÃ²ng láº·p `acquire` tiáº¿p theo.

`condition.release()` cÃ³ Ã½ nghÄ©a lÃ  khi hoÃ n thÃ nh xong viá»‡c má»›i nháº£ lock hoÃ n toÃ n
`condition.wait()`: nháº£ lock táº¡m thá»i Ä‘á»ƒ chá» tÃ­n hiá»‡u tá»« `publisher` hoáº·c thread khÃ¡c.

***Use case***: Ä‘á»ƒ xÃ¢y dá»±ng mÃ´ hÃ¬nh pub-sub


## ***Semaphores***

**Semaphores***: lÃ  má»™t ***internal counter***, nÃ³ sáº½ tÄƒng khi `acquire` vÃ  giáº£m khi `release`.
* GiÃ¡ trá»‹ default cá»§a `semaphore counter` lÃ  1.
* ***Semaphore*** khÃ´ng thá»ƒ bá»‹ `acquired` khi counter < 1.
* Cho phÃ©p nhiá»u thread acquire cÃ¹ng lÃºc, náº¿u counter >= 1.
ChÃºng ta sáº½ bá»c má»™t block code báº±ng má»™t `semaphore` vÃ  set giÃ¡ trá»‹ counter cá»§a nÃ³ = 2. 
Khi má»™ thread `acquired semaphore`, giÃ¡ trá»‹ cá»§a `semaphore` sáº½ giáº£m xuá»‘ng 1 â‡’ lÃ  má»©c tháº¥p nháº¥t, náº¿u cÃ³ thread khÃ¡c `acquired semaphore` Ä‘Ã³ thÃ¬ value cá»§a semaphore lÃºc Ä‘Ã³ giáº£m xuá»‘ng 0 â†” khÃ´ng thá»ƒ `acquired`.

<span style="color: red">Semaphore cho phÃ©p nhiá»u thread cÃ¹ng acquire cÃ¹ng lÃºc, sá»‘ thread tá»‘i Ä‘a Ä‘Æ°á»£c acquire báº±ng vá»›i max value cá»§a semaphore</span>.
<span style="color: green">Náº¿u counter cá»§a semaphore  = 1 â‡’ giá»‘ng nhÆ° Lock thÃ´ng thÆ°á»ng</span>.

Semaphore trong python
```python
class _Semaphore(_Verbose):
    # After Tim Peters' semaphore class, but not quite the same (no maximum)
    def __init__(self, value=1, verbose=None):
        if value < 0:
            raise ValueError("semaphore initial value must be >= 0")
        _Verbose.__init__(self, verbose)
        self.__cond = Condition(Lock())
        self.__value = value
```

VÃ­ dá»¥ sá»­ dá»¥ng semaphore trong bÃ i toÃ¡n bÃ¡n vÃ©
```python
import threading
import time
import random

class TicketSeller(threading.Thread):
    ticketsSold = 0
    def __init__(self, semaphore):
        threading.Thread.__init__(self)
        self.semaphore = semaphore
        print("Ticket Seller Started Work")

    def run(self):
        global ticketsAvailable
        running = True
        while running:
            self.randomDelay()
            self.semaphore.acquire()
            if(ticketsAvailable <= 0):
                running = False
            else:
                self.ticketsSold = self.ticketsSold + 1
                ticketsAvailable = ticketsAvailable - 1
                print("{} Sold One ({} left)".format(self.name, ticketsAvailable))
            self.semaphore.release()
        print("Ticket Seller {} Sold {} tickets in total".format(self.name,
        self.ticketsSold))

    def randomDelay(self):
        time.sleep(random.randint(0,1))

# our sempahore primitive
semaphore = threading.Semaphore(value=3) # GiÃ¡ trá»‹ cá»§a semaphore = 3
# Our Ticket Allocation
ticketsAvailable = 10
# our array of sellers
sellers = []
for i in range(4):
    seller = TicketSeller(semaphore)
    seller.start()
    sellers.append(seller)

# joining all our sellers
for seller in sellers:
    seller.join()
```

***ChÃº Ã½***: Náº¿u khÃ´ng `self.randomDelay()` trÆ°á»›c khi cháº¡y logic thÃ¬ sáº½ bá»‹ thread race, khi Ä‘Ã³ má»™t thread sáº½ bÃ¡n háº¿t toÃ n bá»™ sá»‘ vÃ© do tá»‘c Ä‘á»™ xá»­ lÃ½ quÃ¡ nhanh.

### BoundedSemaphore
Hoáº¡t Ä‘á»™ng tÆ°Æ¡ng tá»± nhÆ° `semaphore` nhÆ°ng sáº½ raise lá»—i an toÃ n hÆ¡n.

Vá»›i `semaphore(n)` thÃ´ng thÆ°á»ng:
* Cho phÃ©p tá»‘i Ä‘a `n` thread truy cáº­p
* KhÃ´ng kiá»ƒm tra sá»‘ láº§n `release()` â‡’ value counter cÃ³ thá»ƒ bá»‹ giáº£m vá» sá»‘ Ã¢m gÃ¢y sai logic
Vá»›i `BoundedSemaphore(n)`:
* Giá»‘ng `semaphore` thÃ´ng thÆ°á»ng
* Náº¿u gá»i `release()` quÃ¡ nhiá»u láº§n â‡’ counter < 1 â‡’ raise Exception


<span style="color: brown; font-style:bold;font-size:20px">Use case</span>:
- Giá»›i háº¡n sá»‘ lÆ°á»£ng káº¿t ná»‘i vÃ o server => táº¡o rate limit
- Táº¡o ra cÃ¡c pool vá»›i giá»›i háº¡n sá»‘ lÆ°á»£ng worker lÃ m cÃ¡c task
- Giá»›i háº¡n cÃ¡c tÃ i nguyÃªn bÃªn ngoÃ i => Database connection pool

## ***Events***

***Events*** lÃ  má»™t cÃ¡ch giao tiáº¿p Ä‘Æ¡n giáº£n giá»¯a cÃ¡c threads cháº¡y song song.
Má»™t thread sáº½ phÃ¡t ra má»™t tÃ­n hiá»‡u `signal` lÃ  cÃ³ má»™t event Ä‘Ã£ xáº£y ra, cÃ¡c thread khÃ¡c sáº½ láº¯ng nghe `signal` nÃ y.

### CÆ¡ cháº¿ hoáº¡t Ä‘á»™ng cá»§a event

***Events*** lÃ  má»™t ***object***, chá»©a má»™t ***internal flag***, ***flag*** nÃ y cÃ³ 2 tráº¡ng thÃ¡i lÃ  ***true (set)*** hoáº·c ***false (unset)***.
CÃ¡c thread sáº½ liÃªn tá»¥c kiá»ƒm tra tráº¡ng thÃ¡i cá»§a flag nÃ y vÃ  thá»±c hiá»‡n hÃ nh Ä‘á»™ng tÆ°Æ¡ng á»©ng khi tráº¡ng thÃ¡i cá»§a flag thay Ä‘á»•i.

* Má»™t thread (Ä‘Ã³ng vai trÃ² `producer`) gá»i `.set()` Ä‘á»ƒ bÃ¡o hiá»‡u ráº±ng Ä‘iá»u gÃ¬ Ä‘Ã³ Ä‘Ã£ sáº£y ra.
* CÃ¡c thread khÃ¡c (Ä‘Ã³ng vai trÃ² `consumer`) gá»i `.wait()` vÃ  chá» sá»± kiá»‡n xáº£y ra (flag Ä‘Æ°á»£c set)

<span style="color: green; font-style:italic">Sá»­ dá»¥ng event Ä‘á»ƒ kiá»ƒm soÃ¡t cÃ¡c threads</span>:
* Python khÃ´ng cÃ³ cÆ¡ cháº¿ nÃ o Ä‘á»ƒ trá»±c tiáº¿p `kill thread`. Do Ä‘Ã³ cÃ³ thá»ƒ sá»­ dá»¥ng `event` Ä‘á»ƒ kiá»ƒm soÃ¡t thá»i gian cháº¡y cá»§a threads.
* Threads cÃ³ thá»ƒ Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ chá»‰ cháº¡y khi Event chÆ°a Ä‘Æ°á»£c set. Khi cáº§n dá»«ng threads má»™t cÃ¡ch an toÃ n, Event sáº½ Ä‘Æ°á»£c set vÃ  thread sáº½ tá»± Ä‘á»™ng káº¿t thÃºc sau khi hoÃ n thÃ nh task.

<span style="color: green; font-style:italic">Æ¯u Ä‘iá»ƒm</span>: sá»­ dá»¥ng khi muá»‘n kill thread má»™t cÃ¡c tá»« tá»«, cho phÃ©p thread hoÃ n thÃ nh cÃ´ng viá»‡c trÆ°á»›c khi bá»‹ kill, thay vÃ¬ dá»«ng Ä‘á»™t ngá»™t báº±ng `SIGKILL` signal cá»§a OS.

Má»™t ***event object*** cÃ³ 4 function chÃ­nh:
* `isSet()`: kiá»ƒm tra xem event Ä‘Ã£ Ä‘Æ°á»£c set hay chÆ°a
* `set()`: set event
* `clear()`: reset toÃ n bá»™ event object, táº¯t flag
* `wait()`: block tá»›i khi internal flag Ä‘Æ°á»£c set = True

```python
import threading
import time

def myThread(stop_event):
    while not stop_event.is_set():
        print("Waiting for Event to be set")
        time.sleep(1)
        print("myEvent has been set")

def main():
    stop_event = threading.Event()
    thread1 = threading.Thread(target=myThread, args=(stop_event,))
    thread1.start()
    time.sleep(10)
    stop_event.set()

if __name__ == '__main__':
    main()
```

Náº¿u `stop_event` chÆ°a Ä‘Æ°á»£c set, thread váº«n sáº½ hoáº¡t Ä‘á»™ng bÃ¬nh thÆ°á»ng, tuy nhiÃªn khi `stop_event` Ä‘Æ°á»£c set, nÃ³ sáº½ cháº¡y ná»‘t logic chÆ°Æ¡ng trÃ¬nh vÃ  dá»«ng thread.

