```table-of-contents
```

# The callback pattern

- **Reactor pattern** lÃ  má»™t mÃ´ hÃ¬nh xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™ (asynchronous) mÃ  trong Ä‘Ã³ cÃ³ má»™t **event loop** tiáº¿p nháº­n cÃ¡c sá»± kiá»‡n (events) vÃ  **chuyá»ƒn tiáº¿p** Ä‘áº¿n cÃ¡c **handler** (trÃ¬nh xá»­ lÃ½).
- Trong Node.js, **callbacks chÃ­nh lÃ  cÃ¡c handler Ä‘Ã³**.
- Khi má»™t sá»± kiá»‡n báº¥t Ä‘á»“ng bá»™ xáº£y ra (vÃ­ dá»¥: Ä‘á»c file xong, nháº­n Ä‘Æ°á»£c dá»¯ liá»‡u tá»« network), má»™t callback sáº½ Ä‘Æ°á»£c gá»i Ä‘á»ƒ xá»­ lÃ½ káº¿t quáº£.

***Closures*** trong Nodejs giÃºp giá»¯ láº¡i context khi gá»i callback
**Closure** lÃ  tÃ­nh nÄƒng cho phÃ©p má»™t hÃ m nhá»› Ä‘Æ°á»£c **biáº¿n trong pháº¡m vi nÆ¡i nÃ³ Ä‘Æ°á»£c táº¡o ra**, ká»ƒ cáº£ sau khi hÃ m ngoÃ i Ä‘Ã£ káº¿t thÃºc.

ğŸ§  VÃ­ dá»¥:
```js
function fetchData(url) {
  const requestId = Math.random()

  http.get(url, (response) => {
    console.log(`Handling response for request #${requestId}`)
  })
}
```

DÃ¹ `requestId` Ä‘Ã£ "háº¿t Ä‘á»i" sau khi `fetchData()` cháº¡y xong, callback truyá»n vÃ o `http.get()` **váº«n nhá»› Ä‘Æ°á»£c nÃ³** â†’ nhá» **closure**.

## The continuation-passing style

Trong javascript, ***callback*** lÃ  má»™t function Ä‘Æ°á»£c truyá»n vÃ o má»™t function khÃ¡c nhÆ° má»™t argument, vÃ  sáº½ Ä‘Æ°á»£c gá»i khi hÃ m caller káº¿t thÃºc vÃ  truyá»n káº¿t quáº£ vÃ o trong callback.

CÃ¡ch truyá»n callback nhÆ° nÃ y gá»i lÃ  ***continuation-passing style (CPS)***.

### Synchronous CPS

VÃ­ dá»¥ vá» synchronous functions
```js
function add (a, b) {
	return a + b
}

// Sá»­ dá»¥ng callback
function addCPS(a, b, callback) {
	callback(a + b)
}
```

Ta gá»i `addCPS` lÃ  `synchronous CPS function`, bá»Ÿi vÃ¬ chá»‰ khi nÃ o hÃ m callback cháº¡y xong thÃ¬ caller cá»§a nÃ³ má»›i completed.

## Asynchronous CPS

vÃ­ dá»¥ vá» Asynchronous CPS
```js
function additionAsync(a, b, callback) {
	setTimeout(() => callback(a + b), 100)
}

console.log('before')

additionAsync(1, 2, result => console.log(`Result: ${result}`)) console.log('after')
```

Sá»­ dá»¥ng `setTimeout` Ä‘á»ƒ add callback vÃ o trong event queue, lÃºc nÃ y, viá»‡c sá»­ dá»¥ng callback má»›i Ä‘Ãºng lÃ  xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™.

![[Pasted image 20250519221513.png]]

## Non-CPS callbacks

CÃ³ nhiá»u trÆ°á»ng há»£p khi tháº¥y má»™t hÃ m cÃ³ tham sá»‘ lÃ  callback (má»™t hÃ m Ä‘Æ°á»£c truyá»n vÃ o Ä‘á»ƒ gá»i láº¡i), chÃºng ta thÆ°á»ng **nghÄ© ngay ráº±ng hÃ m Ä‘Ã³ lÃ  báº¥t Ä‘á»“ng bá»™ (async) hoáº·c Ä‘ang dÃ¹ng kiá»ƒu láº­p trÃ¬nh CPS**

<span style="color:rgb(255, 0, 0)">NhÆ°ng Ä‘iá»u nÃ y khÃ´ng pháº£i lÃºc nÃ o cÅ©ng Ä‘Ãºng.</span> 
VÃ­ dá»¥:
```js
const result = [1, 5, 7].map(element => element - 1);
console.log(result); // [0, 4, 6]
```
- á» Ä‘Ã¢y, hÃ m `map()` nháº­n má»™t callback `element => element - 1`.
- Tuy nhiÃªn, callback nÃ y **khÃ´ng nháº±m má»¥c Ä‘Ã­ch xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™ hay truyá»n tiáº¿p káº¿t quáº£ trong CPS**, mÃ  chá»‰ Ä‘Æ¡n giáº£n Ä‘á»ƒ duyá»‡t tá»«ng pháº§n tá»­ trong máº£ng vÃ  thá»±c hiá»‡n phÃ©p toÃ¡n.
- Káº¿t quáº£ cá»§a `map()` Ä‘Æ°á»£c tráº£ vá» **má»™t cÃ¡ch Ä‘á»“ng bá»™**, tá»©c lÃ  hÃ m tráº£ vá» ngay láº­p tá»©c giÃ¡ trá»‹ káº¿t quáº£, khÃ´ng cáº§n pháº£i Ä‘á»£i hay gá»i láº¡i sau.
- Vá» máº·t cÃº phÃ¡p, **callback khÃ´ng cÃ³ sá»± khÃ¡c biá»‡t rÃµ rÃ ng giá»¯a callback dÃ¹ng theo kiá»ƒu CPS hay callback Ä‘Æ¡n thuáº§n**.

# Khi nÃ o nÃªn sá»­ dá»¥ng Synchronous hoáº·c Asynchronous?

## Unpredictable function

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» unpredictable function
```js
import { readFile } from 'fs';

const cache = new Map();

function inconsistentRead(filename, cb) {
  if (cache.has(filename)) {
    // gá»i callback Ä‘á»“ng bá»™ ngay láº­p tá»©c náº¿u Ä‘Ã£ cÃ³ cache
    cb(cache.get(filename));
  } else {
    // láº§n Ä‘áº§u chÆ°a cÃ³ cache, Ä‘á»c file báº¥t Ä‘á»“ng bá»™
    readFile(filename, 'utf8', (err, data) => {
      cache.set(filename, data);
      cb(data);
    });
  }
}
```

- HÃ m `inconsistentRead` nháº­n má»™t tÃªn file `filename` vÃ  má»™t callback `cb`.

- Náº¿u ná»™i dung file Ä‘Ã£ cÃ³ trong `cache` (bá»™ nhá»› Ä‘á»‡m), hÃ m sáº½ gá»i callback **Ä‘á»“ng bá»™** ngay láº­p tá»©c vá»›i dá»¯ liá»‡u trong cache.

- Náº¿u chÆ°a cÃ³, hÃ m sáº½ gá»i `readFile` Ä‘á»ƒ Ä‘á»c file **báº¥t Ä‘á»“ng bá»™**, vÃ  khi Ä‘á»c xong má»›i gá»i callback vá»›i dá»¯ liá»‡u.

 â¡ï¸HÃ m `inconsistentRead` cÃ³ hÃ nh vi khÃ´ng nháº¥t quÃ¡n, lÃºc thÃ¬ `Ä‘á»“ng bá»™`, lÃºc thÃ¬ `báº¥t Ä‘á»“ng bá»™` â‡’ cÃ¡ch gá»i callback nÃ y gÃ¢y ra cÃ¡c lá»—i khÃ³ Ä‘oÃ¡n, khÃ³ debug
 
âœ… Trong javascript, láº­p trÃ¬nh báº¥t Ä‘á»“ng bá»™ thÆ°á»ng Ä‘Æ°á»£c thiáº¿t káº¿ sao cho ***callback luÃ´n Ä‘Æ°á»£c gá»i báº¥t Ä‘á»“ng bá»™ (async)*** Ä‘á»ƒ dev cÃ³ thá»ƒ dá»± Ä‘oÃ¡n dc hÃ nh vi cá»§a function

## Unleashing Zalgo

Ta cÃ³ vÃ­ dá»¥ Ä‘oáº¡n code sau
```js
import { readFile } from 'fs';

const cache = new Map();

function inconsistentRead(filename, cb) {
  if (cache.has(filename)) {
    // gá»i callback Ä‘á»“ng bá»™ ngay láº­p tá»©c náº¿u Ä‘Ã£ cÃ³ cache
    cb(cache.get(filename));
  } else {
    // láº§n Ä‘áº§u chÆ°a cÃ³ cache, Ä‘á»c file báº¥t Ä‘á»“ng bá»™
    readFile(filename, 'utf8', (err, data) => {
      cache.set(filename, data);
      cb(data);
    });
  }
}

function createFileReader (filename) {
    const listeners = []
    inconsistentRead(filename, value => {
        listeners.forEach(listener => listener(value))
    })
    
    return {
        onDataReady: listener => listeners.push(listener)
    }
}

const reader1 = createFileReader('data.txt')
reader1.onDataReady(data => {
    console.log(`First call data: ${data}`)
    // ...sometime later we try to read again from
    // the same file
    const reader2 = createFileReader('data.txt')
    reader2.onDataReady(data => {
        console.log(`Second call data: ${data}`)
    })
})
```

***BÆ°á»›c 1: `createFileReader('data.txt')` Ä‘Æ°á»£c gá»i (táº¡o `reader1`)***

- HÃ m `createFileReader` khá»Ÿi táº¡o má»™t máº£ng rá»—ng `listeners = []`.
- Gá»i hÃ m `inconsistentRead('data.txt', callback)` vá»›i callback:
```js
value => {
  listeners.forEach(listener => listener(value));
}
```
- á» láº§n Ä‘áº§u Ä‘á»c file, giáº£ sá»­ **cache chÆ°a cÃ³** nÃªn `inconsistentRead` hoáº¡t Ä‘á»™ng **báº¥t Ä‘á»“ng bá»™** (Ä‘á»c file tháº­t, sau Ä‘Ã³ má»›i gá»i callback).
- VÃ¬ `inconsistentRead` chÆ°a gá»i callback ngay, hÃ m `createFileReader` tráº£ vá» Ä‘á»‘i tÆ°á»£ng cÃ³ phÆ°Æ¡ng thá»©c:
```js
onDataReady: listener => listeners.push(listener)
```
LÃºc nÃ y, `listeners` váº«n rá»—ng.

***BÆ°á»›c 2: ÄÄƒng kÃ½ listener cho `reader1`***

- `reader1.onDataReady(data => { ... })` Ä‘Æ°á»£c gá»i.
- HÃ m callback `data => { console.log(...) }` Ä‘Æ°á»£c thÃªm vÃ o máº£ng `listeners`.
- Máº£ng `listeners` giá» cÃ³ 1 pháº§n tá»­ lÃ  callback nÃ y.

***BÆ°á»›c 3: `inconsistentRead` hoÃ n thÃ nh Ä‘á»c file, gá»i callback***

- Sau khi Ä‘á»c file xong, `inconsistentRead` gá»i callback truyá»n vÃ o:
```js
value => {
  listeners.forEach(listener => listener(value));
}
```
* Callback nÃ y sáº½ cháº¡y `listeners.forEach(...)`:
	- Láº¥y tá»«ng listener trong máº£ng, gá»i `listener(value)`.
	- á» Ä‘Ã¢y chá»‰ cÃ³ 1 listener (`reader1` Ä‘Äƒng kÃ½), nÃªn hÃ m Ä‘Ã³ cháº¡y:
```js
data => {
  console.log(`First call data: ${data}`);

  // Táº¡o reader2 á»Ÿ Ä‘Ã¢y
  const reader2 = createFileReader('data.txt');
  reader2.onDataReady(data => {
    console.log(`Second call data: ${data}`);
  });
}
```
* `console.log` in ra dá»¯ liá»‡u cá»§a file láº§n Ä‘áº§u.
* **LÆ°u Ã½:** Táº¡i thá»i Ä‘iá»ƒm nÃ y, ta gá»i `createFileReader('data.txt')` Ä‘á»ƒ táº¡o `reader2` **bÃªn trong callback cá»§a `reader1`**.

***BÆ°á»›c 4: Táº¡o `reader2`***

- Gá»i `createFileReader('data.txt')` láº§n 2.
- Trong `createFileReader`:
    - Táº¡o máº£ng `listeners = []` má»›i cho `reader2`.
    - Gá»i `inconsistentRead('data.txt', callback2)`.
    - Láº§n nÃ y, cache Ä‘Ã£ cÃ³ dá»¯ liá»‡u tá»« láº§n Ä‘á»c Ä‘áº§u tiÃªn.
    - NÃªn `inconsistentRead` gá»i callback **Ä‘á»“ng bá»™ ngay láº­p tá»©c** (khÃ´ng pháº£i Ä‘á»£i).
- Callback2 cháº¡y:
```js
value => {
  listeners.forEach(listener => listener(value));
}
```
* **Tuy nhiÃªn, lÃºc nÃ y `listeners` cá»§a `reader2` váº«n rá»—ng**, vÃ¬ `reader2.onDataReady(...)` chÆ°a Ä‘Æ°á»£c gá»i (chÆ°a Ä‘Äƒng kÃ½ listener).
- VÃ¬ tháº¿, `listeners.forEach` khÃ´ng gá»i Ä‘Æ°á»£c gÃ¬.

***BÆ°á»›c 5: ÄÄƒng kÃ½ listener cho `reader2`***

* Sau khi `createFileReader` tráº£ vá» `reader2`, ta gá»i:
```js
reader2.onDataReady(data => {
  console.log(`Second call data: ${data}`);
});
```
* LÃºc nÃ y callback má»›i Ä‘Æ°á»£c Ä‘áº©y vÃ o `listeners` cá»§a `reader2`.
- NhÆ°ng vÃ¬ callback `inconsistentRead` Ä‘Ã£ Ä‘Æ°á»£c gá»i **trÆ°á»›c Ä‘Ã³ rá»“i**, listener má»›i nÃ y **khÃ´ng bao giá» Ä‘Æ°á»£c gá»i**.

âŒ Trong Ä‘oÃ¡n code trÃªn, do func `inconsistentRead()` hoáº¡t Ä‘á»™ng khÃ´ng nháº¥t quÃ¡n (lÃºc thÃ¬ sync, lÃºc thÃ¬ async) â‡’ cháº¡y sai logic, callback cá»§a reader2 khÃ´ng bao giá» Ä‘Æ°á»£c cháº¡y.
## Sá»­ dá»¥ng synchronous APIs

Äá»ƒ fix Ä‘Æ°á»£c bug trÃªn, chÃºng ta cÃ³ thá»ƒ xá»­ lÃ½ báº±ng cÃ¡ch lÃ m cho hÃ m `inconsistentRead()` hoáº¡t Ä‘á»™ng hoÃ n toÃ n Ä‘á»“ng bá»™ (ko lÃºc thÃ¬ Ä‘á»“ng bá»™ lÃºc thÃ¬ báº¥t Ä‘á»“ng bá»™ nhÆ° trÃªn).

```js 
import { readFileSync } from 'fs'
const cache = new Map()
function consistentReadSync (filename) {
	if (cache.has(filename)) {
		return cache.get(filename)
	} else {
		const data = readFileSync(filename, 'utf8')
		cache.set(filename, data)
		return data
	}
}
```

Trong hÃ m nÃ y, ta sá»­ dá»¥ng hÃ m `readFileSync` Ä‘á»ƒ Ä‘á»c file Ä‘á»“ng bá»™ vÃ  tráº£ vá» káº¿t quáº£ Ä‘á»c ngay.

Nodejs cung cáº¥p má»™t táº­p cÃ¡c API Ä‘á»“ng bá»™ Ä‘á»ƒ xá»­ lÃ½ háº§u háº¿t cÃ¡c I/O operations cÆ¡ báº£n.

<span style="color:rgb(255, 0, 0)">Tuy nhiÃªn viá»‡c sá»­ dá»¥ng cÃ¡c synchronous API thay tháº¿ cho asynchronous API cÃ³ má»™t sá»‘ háº¡n cháº¿ sau</span>:
* synchronous API khÃ´ng kháº£ dá»¥ng cho má»™t sá»‘ tÃ¡c vá»¥ Ä‘áº·c biá»‡t
* synchronous API sáº½ block even loop, nÃ³ sáº½ phÃ¡ vá»¡ Nodejs concurrency model, lÃ m cháº­m á»©ng dá»¥ng.

## Delay viá»‡c gá»i callback sang vÃ²ng láº·p káº¿ tiáº¿p (next tick) cá»§a event loop

NgoÃ i cÃ¡ch trÃªn, Ä‘á»ƒ fixbug, ta cÃ³ thá»ƒ lÃ m cho hÃ m `inconsistentRead()` sáº½ xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™ trong má»i trÆ°á»ng há»£p.
CÃ¡ch lÃ m á»Ÿ Ä‘Ã¢y lÃ  sáº½ <span style="color:rgb(255, 0, 0)">schedule synchronous callback</span> thay vÃ¬ nÃ³ sáº½ thá»±c thi callback ngay láº­p tá»©c ngay trong cÃ¹ng <span style="color:rgb(255, 0, 0)">event loop cycle</span>, thÃ¬ callback Ä‘Ã³ sáº½ Ä‘Æ°á»£c thá»±c thi ***trong tÆ°Æ¡ng lai*** á»Ÿ <span style="color:rgb(255, 0, 0)">event loop cycle tiáº¿p theo</span>.

Trong Nodejs, ta cÃ³ thá»ƒ sá»­ dá»¥ng `process.nextTick()`. <span style="font-weight:bold; color:rgb(146, 208, 80)">HÃ m nay sáº½ Ä‘á»£i cho Ä‘áº¿n khi code hiá»‡n táº¡i hoÃ n táº¥t thÃ¬ má»›i cháº¡y callback</span>.

<span style="font-weight:bold; color:rgb(0, 176, 80)">CÃ¡ch hoáº¡t Ä‘á»™ng cá»§a `prcess.nextTick()` nhÆ° sau:</span>

* truyá»n vÃ o `process.nextTick()` má»™t callback
* Callback nÃ y sáº½ Ä‘Æ°á»£c Ä‘Æ°a vÃ o ***hÃ ng Ä‘áº§u tiÃªn*** cá»§a event queue (event queue)
* Callback do `process.nextTick()` truyá»n vÃ o sáº½ <span style="color:rgb(146, 208, 80)">Ä‘Æ°á»£c cháº¡y trÆ°á»›c táº¥t cáº£ cÃ¡c event I/O</span> nhÆ° (`setTimeout`, `readFile`, network,...)
* Sau khi Ä‘áº©y callback vÃ o queue, hÃ m `process.nextTick()` **sáº½ return ngay láº­p tá»©c**, khÃ´ng block execution.

```js
import { readFile } from 'fs'

const cache = new Map()

function consistentReadAsync (filename, callback) {
	if (cache.has(filename)) {
		// deferred callback invocation
		process.nextTick(() => callback(cache.get(filename)))
	} else {
		// asynchronous function
		readFile(filename, 'utf8', (err, data) => {
			cache.set(filename, data)
			callback(data)
		})
	}
}
```

â¡ï¸ Sá»­ dá»¥ng `process.nextTick()` giÃºp `consistentReadAsync` sáº½ cháº¡y báº¥t Ä‘á»“ng bá»™ trong má»i ngÆ°á»i há»£p.

### Má»™t sá»‘ API khÃ¡c Ä‘á»ƒ trÃ¬ hoÃ£n viá»‡c thá»±c thi code

#### `setImmediate()`

Má»¥c Ä‘Ã­ch cá»§a API nÃ y tÆ°Æ¡ng tá»± `process.nextTick()`, tuy nhiÃªn cÃ³ sá»± khÃ¡c biá»‡t vá» thá»i Ä‘iá»ƒm cháº¡y `callback`.

***ğŸ”¹ `process.nextTick()`***

- **Má»¥c Ä‘Ã­ch:** Thá»±c thi callback **ngay sau khi** Ä‘oáº¡n mÃ£ hiá»‡n táº¡i hoÃ n táº¥t, nhÆ°ng **trÆ°á»›c khi báº¥t ká»³ sá»± kiá»‡n I/O nÃ o** Ä‘Æ°á»£c xá»­ lÃ½.
- cÃ¡c callback nÃ y Ä‘Æ°á»£c gá»i lÃ  **microtask**.
- **Thá»i Ä‘iá»ƒm cháº¡y callback:**
    - **ÄÆ°á»£c thá»±c thi** **ngay sau khi** Ä‘oáº¡n mÃ£ Ä‘á»“ng bá»™ hiá»‡n táº¡i káº¿t thÃºc, **trÆ°á»›c khi vÃ²ng láº·p sá»± kiá»‡n chuyá»ƒn sang báº¥t ká»³ phase nÃ o cá»§a event loop** (bao gá»“m cáº£ xá»­ lÃ½ I/O).
    - TrÆ°á»›c báº¥t ká»³ tÃ¡c vá»¥ nÃ o trong vÃ²ng láº·p sá»± kiá»‡n nhÆ° `setTimeout`, `setImmediate`, hay callback cá»§a I/O.
- **Æ¯u Ä‘iá»ƒm:** Cháº¡y ráº¥t nhanh, há»¯u Ã­ch Ä‘á»ƒ chia nhá» cÃ¡c tÃ¡c vá»¥ Ä‘á»“ng bá»™ lá»›n mÃ  khÃ´ng Ä‘á»ƒ giÃ¡n Ä‘oáº¡n logic.
- **NhÆ°á»£c Ä‘iá»ƒm:** Náº¿u sá»­ dá»¥ng `process.nextTick()` má»™t cÃ¡ch Ä‘á»‡ quy (recursive) mÃ  khÃ´ng "nhÆ°á»ng" CPU, báº¡n cÃ³ thá»ƒ gÃ¢y ra hiá»‡n tÆ°á»£ng **I/O starvation** â€” nghÄ©a lÃ  cÃ¡c sá»± kiá»‡n I/O sáº½ **khÃ´ng bao giá» cÃ³ cÆ¡ há»™i Ä‘Æ°á»£c thá»±c thi**.

***ğŸ”¹ `setImmediate()`***

- **Má»¥c Ä‘Ã­ch:** Thá»±c thi callback sau khi **toÃ n bá»™ I/O hiá»‡n táº¡i** Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½.
- CÃ¡c callback Ä‘Æ°á»£c gá»i lÃ  **macrotask** trong vÃ²ng láº·p sá»± kiá»‡n.
- **Thá»i Ä‘iá»ƒm cháº¡y:** Trong cÃ¹ng má»™t ***event loop cycle*** vá»›i luá»“ng hiá»‡n táº¡i, **sau khi táº¥t cáº£ cÃ¡c I/O events Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½**.
- **Æ¯u Ä‘iá»ƒm:** TrÃ¡nh Ä‘Æ°á»£c I/O starvation. PhÃ¹ há»£p Ä‘á»ƒ lÃªn lá»‹ch cho cÃ´ng viá»‡c cáº§n cháº¡y sau cÃ¡c hoáº¡t Ä‘á»™ng I/O.
- **NhÆ°á»£c Ä‘iá»ƒm:** Cháº¡y cháº­m hÆ¡n má»™t chÃºt so vá»›i `process.nextTick()` vÃ¬ pháº£i Ä‘á»£i I/O hoÃ n táº¥t.

## Nodejs callback conventions

* Callback Ä‘Æ°á»£c truyá»n nhÆ° last argument vÃ o cÃ¡c function

```js
readFile(filename, [options], callback)
```

* Logic xá»­ lÃ½ lá»—i trong callback function luÃ´n Ä‘Æ°á»£c Ä‘áº·t á»Ÿ Ä‘áº§u callback
```js
readFile('foo.txt', 'utf-8', (err, data) => {
	if (err) {
		handleError(err)
	} else {
		processData(data)
	}
})
```

## CÃ¡ch handle lá»—i trong láº­p trÃ¬nh báº¥t Ä‘á»“ng bá»™

### ğŸ”¹ 1. **Synchronous, direct style**:

Khi láº­p trÃ¬nh báº¥t Ä‘á»“ng bá»™,  cÃ¡c hÃ m Ä‘Æ°á»£c gá»i ná»‘i tiáº¿p nhau vÃ  tráº£ vá» káº¿t quáº£ trá»±c tiáº¿p. 
Khi gáº·p lá»—i, **dÃ¹ng `throw` Ä‘á»ƒ nÃ©m lá»—i**. Náº¿u lá»—i khÃ´ng Ä‘Æ°á»£c báº¯t táº¡i chá»—, nÃ³ sáº½ **"nháº£y ngÆ°á»£c lÃªn call stack"** cho Ä‘áº¿n khi gáº·p má»™t `try...catch` báº¯t lá»—i.

VÃ­ dá»¥

```js
function readFileSync(path) {
    if (!fileExists(path)) {
        throw new Error("File not found");
    }
    return "file content";
}

try {
    const data = readFileSync("somefile.txt");
    console.log(data);
} catch (err) {
    console.error("Error:", err.message);
}
```

Náº¿u trong function `readFileSync` khÃ´ng handle vÃ  xá»­ lÃ½ lá»—i, nÃ³ sáº½ nháº£y lÃªn caller cá»§a hÃ m Ä‘Ã³ cho tá»›i khi nÃ o tÃ¬m dc Ä‘oáº¡n `try...catch` Ä‘á»ƒ xá»­ lÃ½ lá»—i.

### ğŸ”¹ 2. **Asynchronous CPS (Continuation-Passing Style)**:

Trong láº­p trÃ¬nh báº¥t Ä‘á»“ng bá»™,  KhÃ´ng `return` giÃ¡ trá»‹ trá»±c tiáº¿p mÃ  gá»i má»™t **callback function**, vÃ  náº¿u cÃ³ lá»—i, truyá»n lá»—i Ä‘Ã³ vÃ o callback **thay vÃ¬ `throw error`**.

ÄÃ¢y lÃ  phong cÃ¡ch phá»• biáº¿n trÆ°á»›c khi `Promise` vÃ  `async/await` ra Ä‘á»i trong JavaScript, nhÆ° Node.js style:

```js
import { readFile } from 'fs'

function readJSON(filename, callback) {
	readFile(filename, 'utf8', (err, data) => {
		let parsed
		if (err) {
			// propagate the error and exit the current function
			return callback(err)
		}
		try {
			parsed = JSON.parse(data)
		} catch (err) {
			// catch parsing errors
			return callback(err)
		}
		// no errors, propagate just the data
		callback(null, parsed)
	})
}
```

Lá»—i sáº½ Ä‘Æ°á»£c xá»­ lÃ½ trong callback.

### âš ï¸Uncaught exceptions

Trong thá»±c táº¿, cÃ³ nhiá»u trÆ°á»ng há»£p má»™t errors Ä‘Æ°á»£c `thrown` ra, vÃ  khÃ´ng Ä‘Æ°á»£c `caught` trong logic cá»§a callback. Trong vÃ­ dá»¥ trÃªn, náº¿u khÃ´ng cÃ³ `try...catch` thÃ¬ khi `JSON.parse` cÃ³ exception, nÃ³ sáº½ khÃ´ng Ä‘Æ°á»£c xá»­ lÃ½.

Viá»‡c `throw` má»™t error **bÃªn trong má»™t hÃ m callback báº¥t Ä‘á»“ng bá»™**, lá»—i Ä‘Ã³ **sáº½ khÃ´ng Ä‘Æ°á»£c báº¯t bá»Ÿi hÃ m cha hoáº·c báº¥t ká»³ callback nÃ o khÃ¡c**.

Lá»—i Ä‘Ã³ khÃ´ng Ä‘Æ°á»£c xá»­ lÃ½ trong "stack" hiá»‡n táº¡i nÃªn nÃ³ **nháº£y ra khá»i callback vÃ  tá»›i event loop** cá»§a Node.js â€“ Ä‘Ã¢y lÃ  nÆ¡i quáº£n lÃ½ táº¥t cáº£ cÃ¡c sá»± kiá»‡n async nhÆ° I/O, timer, v.v.

NÃ³i cÃ¡ch khÃ¡c, **báº¡n khÃ´ng thá»ƒ truyá»n lá»—i Ä‘Ã³ sang cÃ¡c callback khÃ¡c** nhÆ° thÆ°á»ng tháº¥y trong continuation-passing style (CPS). VÃ¬ báº¡n `throw` thay vÃ¬ dÃ¹ng `callback(err)` nÃªn:

- CÃ¡c hÃ m khÃ¡c **khÃ´ng biáº¿t cÃ³ lá»—i xáº£y ra**
- Lá»—i **khÃ´ng Ä‘Æ°á»£c kiá»ƒm soÃ¡t** vÃ  khÃ´ng cÃ³ cÆ¡ há»™i Ä‘á»ƒ xá»­ lÃ½.

Khi gáº·p lá»—i nÃ y, Node.js sáº½:
- **In lá»—i vÃ  stack trace ra stderr**
- **ThoÃ¡t chÆ°Æ¡ng trÃ¬nh** vá»›i exit code khÃ¡c `0` (thÆ°á»ng lÃ  `1`) â€“ biá»ƒu thá»‹ ráº±ng chÆ°Æ¡ng trÃ¬nh gáº·p lá»—i.

---

# The Observer pattern

Má»™t pattern quan trá»ng khÃ¡c Ä‘Æ°á»£c sá»­ dá»¥ng song song vá»›i ***Reactor pattern vÃ  callback*** trong Nodejs lÃ  `Observer pattern`.

Sá»± khÃ¡c nhau giá»¯a ***Callback pattern*** vÃ  ***Observer pattern*** lÃ  má»™t subject cÃ³ thá»ƒ `notify` cho nhiá»u `observers` cÃ¹ng lÃºc, trong khi Ä‘Ã³ thÃ¬ á»Ÿ `CPS callback` (trong callback pattern) thÃ¬ chá»‰ truyá»n káº¿t quáº£ vÃ o má»™t callback (má»™t listener) duy nháº¥t.

## The EventEmitter

***Observer pattern*** Ä‘Æ°á»£c built sáºµn trong core cá»§a Nodejs vÃ  Ä‘Æ°á»£c sá»­ dá»¥ng thÃ´ng qua <span style="color:rgb(255, 0, 0)"><code>EventEmitter</code></span> class.

<span style="color:rgb(255, 0, 0)"><code>EventEmitter</code></span> cho phÃ©p **Ä‘Äƒng kÃ½ má»™t hoáº·c nhiá»u hÃ m callback** Ä‘Æ°á»£c gá»i lÃ  **"listeners"**
Nhá»¯ng listener nÃ y **gáº¯n vá»›i má»™t loáº¡i event cá»¥ thá»ƒ** (nhÆ° `'data'`, `'end'`, `'error'`, v.v.)

![[Pasted image 20250525222639.png]]

```js
import { EventEmitter } from 'events'

const emitter = new EventEmitter()
```

Má»™t sá»‘ hÃ m quan trong mÃ  `EventEmitter` cung cáº¥p:
* `on(event, listener)`: method nÃ y cho phÃ©p Ä‘Äƒng kÃ½ má»™t new listener (má»™t function) gáº¯n vá»›i má»™t loáº¡i event (má»™t string)
* `once(event, listener)`: tÆ°Æ¡ng tá»± nhÆ° `on`, nhÆ°ng `listener` nÃ y sáº½ bá»‹ xÃ³a sau khi `event` Ä‘Æ°á»£c emit láº§n Ä‘áº§u tiÃªn (tá»©c lÃ  chá»‰ láº¯ng nghe event 1 láº§n duy nháº¥t).
* `emit(event, [arg1], [...]`: method nÃ y emit ra má»™t event, truyá»n vÃ o cÃ¡c arguments cáº§n thiáº¿t Ä‘á»ƒ gá»­i cho listeners. Listener sáº½ cÃ³ dáº¡ng `function([arg1], [...])`
* `removeListener(event, listener)`: xÃ³a má»™t listener, listener nÃ y khÃ´ng láº¯ng nghe loáº¡i event Ä‘Æ°á»£c chá»‰ Ä‘á»‹nh.

Má»™t sá»‘ tÃ­nh cháº¥t cá»§a `EventEmitter`

- Má»™t `EventEmitter` cÃ³ thá»ƒ phÃ¡t nhiá»u loáº¡i sá»± kiá»‡n (`'greet'`, `'error'`, `'data'`, v.v.).
- Má»—i loáº¡i sá»± kiá»‡n cÃ³ thá»ƒ cÃ³ nhiá»u listener.
- Khi sá»± kiá»‡n Ä‘Æ°á»£c phÃ¡t (`emit`), táº¥t cáº£ listener cá»§a sá»± kiá»‡n Ä‘Ã³ Ä‘Æ°á»£c gá»i.

## Táº¡o vÃ  sá»­ dá»¥ng EventEmitter

```js
import { EventEmitter } from 'events'
import { readFile } from 'fs'

function findRegex (files, regex) {
    const emitter = new EventEmitter()
    for (const file of files) {
        readFile(file, 'utf8', (err, content) => {
            if (err) {
                return emitter.emit('error', err)
            }
            emitter.emit('fileread', file)
            const match = content.match(regex)
            if (match) {
                match.forEach(elem => emitter.emit('found', file, elem))
            }
        })
    }
    return emitter
}

findRegex(['fileA.txt', 'fileB.json'],/hello \w+/g)
    .on('fileread', file => console.log(`${file} was read`))
    .on('found', (file, match) => console.log(`Matched "${match}" in ${file}`))
    .on('error', err => console.error(`Error emitted ${err.message}`))
```

CÃ³ 3 listener Ä‘Æ°á»£c Ä‘Äƒng kÃ½ cho 3 loáº¡i event tÆ°Æ¡ng á»©ng:
* `fileread`: event nÃ y xáº£y ra khi file Ä‘ang Ä‘Æ°á»£c Ä‘á»c
* `found`: event nÃ y sáº£y ra khi cÃ³ chuá»—i match vá»›i regex
* `error`: event Ä‘Æ°á»£c báº¯n ra khi cÃ³ lá»—i Ä‘á»c file.
Táº¡i má»—i trÆ°á»ng há»£p, `findRegex` sáº½ báº¯n ra cÃ¡c event tÆ°Æ¡ng á»©ng Ä‘á»ƒ cÃ¡c listener xá»­ lÃ½.

VÃ­ dá»¥ khÃ¡c vá» cÃ¡ch sá»­ dá»¥ng `EventEmitter`
```js
const EventEmitter = require('events');

const emitter = new EventEmitter();

emitter.on('greet', () => {
    console.log('Hello there!');
});

emitter.on('greet', () => {
    console.log('Another listener for greet!');
});

emitter.emit('greet');

// Output:
// Hello there!
// Another listener for greet!
```

```sql
+-------------+            emit('greet')           +------------------+
|             |----------------------------------->| Listener 1       |
| EventEmitter|                                    +------------------+
|   object    |                                    +------------------+
|             |----------------------------------->| Listener 2       |
+-------------+            emit('error')           +------------------+
```

## Propagating Errors

TÆ°Æ¡ng tá»± nhÆ° callback, `EventEmitter` khÃ´ng `throw exception` khi cÃ³ lá»—i xáº£y ra. Thay vÃ o Ä‘Ã³, nÃ³ `emit` ra má»™t `special event` Ä‘Æ°á»£c gá»i lÃ  `error`. Cáº§n cÃ³ má»™t listener riÃªng láº¯ng nghe event `error` nÃ y.

## Object observable

`EventEmitter` lÃ  má»™t class trong nodejs. Do Ä‘Ã³ ta cÃ³ thá»ƒ táº¡o ra cÃ¡c class con káº¿ thá»«a class nÃ y Ä‘á»ƒ nÃ³ trá»Ÿ thÃ nh má»™t `Observable object`.

```js
import { EventEmitter } from 'events'
import { readFile } from 'fs'

class FindRegex extends EventEmitter {
    constructor (regex) {
        super()
        this.regex = regex
        this.files = []
    }
    
    addFile (file) {
        this.files.push(file)
        return this
    }

    find () {
        for (const file of this.files) {
            readFile(file, 'utf8', (err, content) => {
                if (err) {
                    return this.emit('error', err)
                }
                this.emit('fileread', file)

                const match = content.match(this.regex)
                if (match) {
                    match.forEach(elem => this.emit('found', file, elem))
                }
            })
        }
        return this
    }
}

const findRegexInstance = new FindRegex(/hello \w+/)
findRegexInstance
.addFile('fileA.txt')
.addFile('fileB.json')
.find()
.on('found', (file, match) => console.log(`Matched "${match}" in file
${file}`))
.on('error', err => console.error(`Error emitted ${err.message}`))
```